# Executive Summary
In this assignment, we will create procedures and functions that allow us to run complex tasks by simply calling with one line of code. One procedure will tell us if there are less than 17 products or not, another procedure will attempt to add a new category name, and we’ll make a function that returns the discounted prices of items.

# Stored Programs
Our first task is to create a procedure called ProductCount that looks at the products table, counts the number of products, and tells us (shows a message by way of a SELECT statement) if we have less than 17, or if we have greater than or equal to 17. We start our script with a DELIMITER statement that sets the delimiter to double slash (//), so that we can use the semicolon delimiter within the procedure. Next, we’ll use the DROP PROCEDURE IF EXISTS statement right before the CREATE PROCEDURE statement to create or replace our new procedure called ProductCount. We’ll make a new block with BEGIN and END, and we’ll use the new delimiter to end it. Inside the block, we’ll DECLARE an INT variable that we will use to count the number of products, and then we’ll use a SELECT statement and the aggregate function COUNT to put that value into the variable with the INTO keyword. Finally, we’ll build an IF statement to check if the variable is greater than or equal to (>=) 17, and an accompanying ELSE statement that is used if that is not the case. A SELECT statement will exist in each of them to tell us which one was chosen. After the procedure is defined, we’ll set the delimiter back to the semicolon, and use the CALL statement to run the procedure by name.

The second task asks us to create a procedure called InsertCategory that attempts to insert a new product category called “Flute”. The instructions say to use the products table, but I think the categories table will make more sense here. Very similar to task one, we’ll change the delimiter, drop and create the procedure, make a block, reset the delimiter, and call the procedure. However, the contents of the procedure are a bit different. The categories table has a constraint that ensures that each category name is unique, so trying to enter a new category that already exists will cause an error. Therefore, our procedure will depend on an exception handler that will be thrown if there was a problem trying to insert the new category. We can achieve this by putting the INSERT statement inside of its own block, and declaring an exit handler variable. That means that if there is an error during the INSERT operation, we can exit the block and handle the problem however we want. In this case, we will handle the problem by telling the user (with a SELECT statement message) that the row could not be inserted because it was a duplicate entry. We’ll use the DECLARE EXIT HANDLER statement and the error code 1062. We want 1062 because it is the error code that occurs when a unique value constraint is challenged, which is the situation we want to account for when our INSERT statement operates. So, if the error occurs we will safely exit the block, and we will have an IF statement there to let us know whether the INSERT was successful or not by using the exit handler variable. Running this script for the first time should successfully add the new category, but repeated runs should report failure because the category will now exist already. We can use a DELETE FROM statement on the side to remove the “Flute” category if we want to test the successful outcome again.

Finally, the third task is to create a function called item_price that returns the discounted price of an item in the order_items table. The discounted price can be calculated by subtracting the discount_amount value from the item_price value. In contrast to the procedures in the previous tasks, this function will be called without the CALL keyword, and it will need the item_id value passed to it as a parameter in the parentheses. Then inside of the function, we will use that item_id value to find the corresponding price values. So, the first thing to do in our function is to define that parameter, which in this case will be an INT. Then we will specify the type of value that will be returned by our function with the RETURNS statement, which in this case will be a DECIMAL value (the discounted price). Then we need to specify the characteristics of our function. In this case, our function is DETERMINISTIC, and it will READ SQL DATA. Now we are ready to write the content of our function. It is quite simple; we will write a SELECT statement that gets the discounted price from the order_items table, but we will use a WHERE clause to get only the one with the item_id that was passed in as the parameter. This SELECT statement will be the output of our function, so we will place it after a RETURN statement. I got an error here because I forgot that parentheses are required for the RETURN statement. After our function is complete, we can test it by including it as a column in a SELECT statement that uses the order_items table. Simply include the item_id column name inside the parentheses as the parameter, and it will return the discounted price for each item_id.

# Conclusion
This has been my favorite assignment so far. I enjoy making procedures and functions to make complex tasks easier and to modularize the workload. It was also a pleasant surprise to see that this kind of functionality was possible with MySQL. I was also able to enjoy it more because it’s more similar to the Java and C# coding that I’m used to. However, I imagine these chapters would be quite difficult for someone who didn’t have much programming experience, since the code here is quite unusual compared to the SQL code that we’ve been learning elsewhere in the book so far.
